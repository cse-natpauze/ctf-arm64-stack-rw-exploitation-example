#include <stdio.h>
#include <stdlib.h> // exit, atoi
#include <unistd.h> // read, write, close
#include <arpa/inet.h> // sockaddr_in, AF_INET, SOCK_STREAM, INADDR_ANY, socket etc...
#include <string.h> // memset

#define PORT 3000
#define MAX_MSG_LEN 0x100


/*
    This program opens a TCP socket, and listens for incoming connections.
    Messages follow a very simple format. The first 8 bytes determine the message length, 
    and messages are terminated with a new line char.


*/


//handle a message of type 1, echo (the only type of message this silly program supports)
void handleMsgType1(int clientFd){
    int ret =-1;
    char buffer[MAX_MSG_LEN];
    //zero out the buffer 
    memset(buffer, 0, MAX_MSG_LEN);
    //read the first 8 bytes to get the len
    uint64_t len = 0;
    ret = read (clientFd,&len,sizeof(uint64_t));
    if ( ret < 0 ) {
        perror("read error");
        exit(5);
    }
    printf("msg len is going to be 0x%0lx\n", len);
    printf("msg len is going to be %ld\n", len);
    //read loop
    for( int i =0; i < len; i++){
        //read a character 
        char c = 0;
        int size = read(clientFd, &c, sizeof(char));
        if ( size < 0 ) {
            perror("read error");
            exit(5);
        }
        buffer[i] = c;
        if(c == '\n'){
            break;
        }
        
    }
    
    printf("received %s from client\n", buffer);
    if (write(clientFd, buffer, len) < 0) {
        perror("write error");
        exit(6);
    }
    return;
}

//prints out the secret key. if you get execution to run this function youve won 
void printkeyout(){
    //in a real ctf puzzle, I would load this value at run time, from a file on the remote target. 
    printf("secret key here, congrats, you won");
}

void messageHandleWrapper(int clientFd){
    printf("handling message");
    handleMsgType1(clientFd);

}

int main(void) { 
    printf("Hello, I'm executing ARM64 instructions!\n"); 
    system("pwd"); // for .... reasons
    //socket handling code ripped from the interwebs 
    int serverFd, clientFd; //file descriptors for socket objects
    struct sockaddr_in server, client;
    int len;
    
    serverFd = socket(AF_INET, SOCK_STREAM, 0);
    if (serverFd < 0) {
        perror("Cannot create socket");
        exit(1);
    }
    //set socket properties so we can reuse it (so we dont need to wait a minute before restarting if we unexpectedly crash or shutdown)
    int enable = 1;
    if (setsockopt(serverFd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0){
        perror("setsockopt(SO_REUSEADDR) failed");
    }
    server.sin_family = AF_INET; //AF_INET = ipv4, we could also use AF_UNIX if we wanted to use unix sockets for local IPC 
    server.sin_addr.s_addr = INADDR_ANY; //listen on all interfaces 
    server.sin_port = htons(PORT); //htons() is for converting endianness between machine and network
    if (bind(serverFd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        perror("Cannot bind socket");
        exit(2);
    }
    if (listen(serverFd, 10) < 0) { // listen on our socket with a queue of 10 
        perror("Listen error");
        exit(3);
    }
    //listen loop
    while (1) {
        len = sizeof(client);
        printf("waiting for client\n");
        if ((clientFd = accept(serverFd, (struct sockaddr *)&client, &len)) < 0) {
            perror("accept error");
            exit(4);
        }
        char *client_ip = inet_ntoa(client.sin_addr);
        printf("Accepted new connection from a client %s:%d\n", client_ip, ntohs(client.sin_port));
        messageHandleWrapper(clientFd);
        close(clientFd);
    }
    close(serverFd);
    return 0;
        
}